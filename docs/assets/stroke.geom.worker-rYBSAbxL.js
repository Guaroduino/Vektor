(function(){"use strict";let A=1,v=1,R=16,S=.1,b=[1,1,1],H=!1,I=.5,c=[],m=null,g=null;function M(s,t){return[s/A*2-1,t/v*-2+1]}function G(s,t,n){if(s.length>=3){const i=s[s.length-3],e=t,o=n;let a=e.x-i.x,r=e.y-i.y,l=Math.hypot(a,r)||1;const f=a/l,x=r/l;let _=o.x-e.x,h=o.y-e.y,p=Math.hypot(_,h)||1;const F=_/p,w=h/p;let u=f+F,d=x+w,y=Math.hypot(u,d);return y<.001?[-x,f]:[-d/y,u/y]}else{let i=n.x-t.x,e=n.y-t.y,o=Math.hypot(i,e);return o<.001?[1,0]:[-e/o,i/o]}}function L(s){const t=[],n=[],i=[];let e=0;for(let o=0;o<s.length;o++){const a=s[o],r={x:a.x,y:a.y,p:a.p??.5,t:a.t??performance.now()},l=c.length>0?c[c.length-1]:null;if(c.push(r),c.length>3&&c.shift(),!l)continue;const[f,x]=G(c,l,r),_=r.p??.5;let h=1;if(H&&l){const u=Math.max(1,r.t-l.t),y=Math.hypot(r.x-l.x,r.y-l.y)/u,z=Math.max(0,Math.min(1,y/2));h=1+(1-.8*I-1)*z}const p=R*_*h*.5,F=[r.x+f*p,r.y+x*p],w=[r.x-f*p,r.y-x*p];if(m&&g){const[u,d]=m,[y,z]=g,[k,W]=F,[C,N]=w,[T,U]=M(u,d),[V,j]=M(y,z),[q,D]=M(k,W),[E,J]=M(C,N);t.push(T,U,V,j,q,D,E,J);for(let B=0;B<4;B++)n.push(b[0],b[1],b[2],Math.max(0,Math.min(1,S)));i.push(e+0,e+1,e+2,e+1,e+3,e+2),e+=4}m=F,g=w}return t.length===0?null:{pos:new Float32Array(t),col:new Float32Array(n),idx:new Uint16Array(i)}}self.onmessage=s=>{const t=s.data;if(t){if(t.type==="init"){A=Math.max(1,t.width|0),v=Math.max(1,t.height|0),self.postMessage({type:"log",msg:"geom worker initialized"});return}if(t.type==="params"){R=t.size,S=t.alpha,b=t.colorRGB,typeof t.sizeFromSpeed<"u"&&(H=!!t.sizeFromSpeed),typeof t.speedInfluence=="number"&&(I=Math.max(0,Math.min(1,t.speedInfluence)));return}if(t.type==="reset"){c=[],m=null,g=null;return}if(t.type==="points"){const n=L(t.points);if(!n)return;self.postMessage({type:"geometry",positions:n.pos,colors:n.col,indices:n.idx},[n.pos.buffer,n.col.buffer,n.idx.buffer]);return}}}})();
